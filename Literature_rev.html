<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>literature_rev</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Literature_rev_files/libs/clipboard/clipboard.min.js"></script>
<script src="Literature_rev_files/libs/quarto-html/quarto.js"></script>
<script src="Literature_rev_files/libs/quarto-html/popper.min.js"></script>
<script src="Literature_rev_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Literature_rev_files/libs/quarto-html/anchor.min.js"></script>
<link href="Literature_rev_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Literature_rev_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Literature_rev_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Literature_rev_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Literature_rev_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<section id="literature-review" class="level1">
<h1>Literature Review</h1>
<p>Due to the raising popularity in recent years of cryptocurrency, there has been a lot of research related to digital currency, from which the field of asset pricing is no exception. The latter because there is a growing interest related to the study of the factors that affect the returns of this type of assets, which certainly translates into a lot of studies whose objective is the previously mentioned. While the research topics may seem similar, it is important to note that this allows for a comprehensive categorization of the studies, despite the broadness of the related research. The first group corresponds to the empirical studies that test for the performance of widely accepted asset pricing models such as the CAPM , FF3 , FF5 , Carhart , among others. The methodology is based on the recollection of data related to returns on a specific set of cryptocurrencies in a particular time period, to then calculate the factors of the models mentioned previously. Due to the great amount of investigation that follows said framework, there are also a lot of studies that in addition to the steps mentioned previously, they complement the study with techniques that help understand better the underlying phenomena. For the better understanding of these groups of studies, some will be discussed that will most definitely aid the current investigation. A first study that is included in the group of empirical studies is the one done by . In this investigation they demonstrate that investors obtain abnormal excess returns on the London Stock Exchange from the years 2014 to 2017. The main reason behind was because of earlier studies, like , that found evidence of inefficiency and the lack of regulation related to the cryptocurrency market. The data used corresponds to daily returns of all London Stock Exchange listed securities from the years 2014-2017, where they conclude that, applying CAPM, FF3, Carhart, and FF5, investors do indeed obtain excess returns by speculating in cryptocurrencies. suggesting that they are inefficient. While this memoir primarily does not explore into the efficiency of cryptocurrency markets, the insights from underline the broad applicability and versatility of such studies.\ Another study is the one done by , where they find that there are three factors that capture the cross-sectional expected cryptocurrency returns. Despite not forming part of the gross of the investigation, this study mentions a very interesting aspect corresponding to the different opinions people have related to cryptocurrency; they say there are two views about the related market. The first one says that all coins represent bubbles and fraud. And, the second states the technology behind said markets may become an important innovation and that at least some coins may become assets that represent stake in the future of the related technology . With the current information of cryptocurrency markets it is difficult to establish right from wrong with respect to said opinions, but either way, empirical studies like contribute largely to understand the factors that better explain the returns of corresponding assets. Now, regarding the research itself, the factors studied were cryptocurrency size, momentum, volume, and volatility. It is important to mention that the study focus only on said market-factors, because financial and accounting data was not available for the cross section of the coins that were analyzed in the data.\ Regarding the conclusions drawn from said investigation, there are several to consider. Firstly, that size and momentum factors well capture the cross-section of cryptocurrnecy returns. Furthermore, a three-factor model can be constructed using market information is successful in pricing the strategies in the cryptocurrency market. A number of theoretical explanations are drawn for the factors. In relation to the cryptocurrency size premium; the cryptocurrency size factor relates to the liquidity effect. Secondly, they find some evidence that the size premium is consistent with a mechanism proposed by cryptocurrency theories: the trade-off between capital gains and the convenience yield. As to momentum, the conclusions show that they are in line with the investor overreaction channel, indicating the tendency of investors to react disproportionately to new information, which in turn causes the price of cryptocurrency to swing more than it should according to its intrinsic value .\ Continuing the line of empirical validation studies, investigated whether an investing strategy modeled by a prospect theory leads to a risk-adjusted outperformance, based on different factor models which include the . The utilization of prospect theory fits well in modeling the way investors inform themselves about a certain cryptocurrency, since they usually look at the price chart and then mentally represent a historical return distribution. So, according to , by looking a the price chart of cryptocurrency, investors evaluate the skeweness and evaluate the asset as a gamble, similar to lottery. The conclusions imply that cryptocurrency holders choose high prospect theory values over low values, with investors generally favoring the latter. Due to this predilection, cryptocurrencies with high prospect theory values are overbought, which reduces future gains. Cryptocurrencies with low prospect theory values, on the other hand, are less likely to be overbought and might result in larger future returns.\ While the previous study presented did not place significant emphasis on the regression models themselves, it uses said models as a complement of the main model of the investigation, which was the prospect theory model.\ Another approach to the asset pricing of cryptocurrency is the one taken by , where a regression model is estimated using cost of production factors, rather than the usual market factors that comprise the most popular asset pricing models. Concerning the factors, concludes that more than 84% of value formation can be explained by three variables: computational power (as a representative for mining difficulty), rate of coin production, and the relative hardness of the mining algorithm employed.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>